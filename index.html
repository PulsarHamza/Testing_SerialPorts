<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Connection Test</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background-color: #53Af3B;
      margin: 0;
      padding: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }
    .container {
      background-color: #fff;
      border-radius: 10px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
      padding: 20px;
      width: 90%;
      max-width: 400px;
      text-align: center;
    }
    h1 {
      margin-bottom: 20px;
      color: #333;
    }
    textarea, input[type="text"] {
      margin-bottom: 30px;
      padding: 10px;
      border: 1px solid #ccc;
      border-radius: 5px;
      width: 100%;
      box-sizing: border-box;
    }
    button {
      margin: 10px;
      padding: 10px 20px;
      border: none;
      border-radius: 5px;
      background-color: #FFA500;
      color: white;
      cursor: pointer;
    }
    button:disabled {
      background-color: #4CAF50;
      cursor: not-allowed;
    }
    button.reset {
      background-color: #FFA500;
      cursor: pointer;
    }
    button:hover:not(:disabled) {
      background-color: #4CAF50;
    }
    #picture {
      margin-top: 20px;
      width: 50%;
      max-height: 100px;
      max-width: 100px;
      height: auto;
      display: block;
      margin-left: auto;
      margin-right: auto;
    }
    #hostTunnelButton.disabled {
      background-color: #4CAF50;
      cursor: not-allowed;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1 id="header">Unite Host Tunnelling</h1>
    <select id="connectionTypeSelect">
      <option value="serial">Serial</option>
      <option value="bluetooth">Bluetooth</option>
    </select>
    <select id="baudRateSelect" style="display: none;">
      <option value="9600">9600</option>
      <option value="19200">19200</option>
      <option value="38400">38400</option>
      <option value="57600">57600</option>
      <option value="115200" selected>115200</option>
    </select>
    <textarea id="sendData" rows="3" placeholder="Enter string to send" spellcheck="false"></textarea>
    <textarea id="logData" rows="10" readonly></textarea>
    <input type="text" id="deviceInfo" readonly>
    <button id="connectButton">Connect</button>
    <button id="clearButton">Clear Log</button>
    <button id="hostTunnelButton">Host Tunnel Mode</button>
    <button id="disconnectButton" onclick="sendDisconnectCommand()">Disconnect Host Tunnel</button>
    <img id="picture" src="pulsarlogo.jpg" alt="Placeholder Picture">
  </div>

  <script>
  let port;
let bluetoothDevice;
let receivedDataArray = [];
let receiveBuffer = '';
let receiveTimeout;

async function connect() {
  const connectionType = document.getElementById('connectionTypeSelect').value;
  if (connectionType === 'serial') {
    if (navigator.serial) {
      await connectToSerialPort();
    } else {
      alert('Web Serial API not supported in this browser. Connecting via Bluetooth instead.');
      await connectToBluetooth();
    }
  } else if (connectionType === 'bluetooth') {
    await connectToBluetooth();
  }
}

async function connectToSerialPort() {
  try {
    port = await navigator.serial.requestPort();
    const baudRate = 115200; // Set baud rate to 115200
    await port.open({ baudRate: baudRate });
    console.log('Serial port connected successfully!');
    document.getElementById('connectButton').disabled = true;
    document.getElementById('header').innerText = `Unite Host Tunnelling - Connected (Serial)`;
    await listenToPort();
  } catch (err) {
    console.error('Error connecting to serial port:', err);
    alert('Error connecting to serial port. Please try again.');
  }
}

async function connectToBluetooth() {
  try {
    bluetoothDevice = await navigator.bluetooth.requestDevice({
      acceptAllDevices: true,
      optionalServices: ['battery_service']
    });
    const server = await bluetoothDevice.gatt.connect();
    console.log('Bluetooth device connected successfully!');
    document.getElementById('connectButton').disabled = true;
    document.getElementById('header').innerText = `Unite Host Tunnelling - Connected (Bluetooth)`;
    // Implement listening and communication logic here
  } catch (err) {
    console.error('Error connecting to Bluetooth device:', err);
    alert('Error connecting to Bluetooth device. Please try again.');
  }
}

async function sendTX(stringToSend) {
  try {
    if (!port) {
      console.error('Serial port is not connected.');
      return;
    }
    const writer = port.writable.getWriter();
    if (stringToSend !== "+++") {
      stringToSend += '\r\n';
    }
    const data = new TextEncoder().encode(stringToSend);
    await writer.write(data);
    console.log('Data sent:', stringToSend);
    writer.releaseLock();
    if (stringToSend.trim() === "SENDPART1") {
      receivedDataArray = [];
    }
  } catch (error) {
    console.error('Error sending data:', error);
    alert('Error sending data. Please check the connection and try again.');
  }
}

async function listenToPort() {
  const reader = port.readable.getReader();
  try {
    while (true) {
      const { value, done } = await reader.read();
      if (done) {
        console.log('[readLoop] DONE');
        break;
      }
      if (value) {
        const receivedString = new TextDecoder('utf-8').decode(value);
        receiveBuffer += receivedString;
        clearTimeout(receiveTimeout);
        receiveTimeout = setTimeout(processReceivedData, 50);
        if (receiveBuffer.endsWith('\r')) {
          processReceivedData();
        }
      }
    }
  } catch (error) {
    console.error('[readLoop] ERROR', error);
    alert('Error receiving data. Please check the connection and try again.');
  } finally {
    reader.releaseLock();
  }
}

function processReceivedData() {
  const hex_array = convertStringToFloatArray(receiveBuffer);
  logData("\nRX (hex): " + hex_array);
  logData("\nRX (ascii): " + receiveBuffer);
  receiveBuffer = '';
}

function convertStringToFloatArray(hexString) {
  var floatArray = [];
  for (var i = 0; i < hexString.length; i += 8) {
    var hexFloat = hexString.substring(i, i + 8);
    floatArray.push(hexToFloat(hexFloat));
  }
  return floatArray;
}

function hexToFloat(hex) {
  var view = new DataView(new ArrayBuffer(4));
  view.setUint32(0, parseInt(hex, 16), false);
  return view.getFloat32(0, false);
}

function logData(data) {
  const logTextarea = document.getElementById('logData');
  logTextarea.value += data;
}

document.getElementById('clearButton').addEventListener('click', function() {
  document.getElementById('logData').value = '';
});

document.getElementById('connectButton').addEventListener('click', connect);

document.getElementById('hostTunnelButton').addEventListener('click', function() {
  sendTX("host tunnel");
  const hostTunnelButton = document.getElementById('hostTunnelButton');
  hostTunnelButton.disabled = true;
  hostTunnelButton.classList.remove('reset');
  hostTunnelButton.classList.add('disabled');
});

function sendDisconnectCommand() {
  sendTX("+++");
  const hostTunnelButton = document.getElementById('hostTunnelButton');
  hostTunnelButton.disabled = false;
  hostTunnelButton.classList.remove('disabled');
  hostTunnelButton.classList.add('reset');
}

document.getElementById('sendData').addEventListener('keypress', function(event) {
  if (event.key === 'Enter') {
    event.preventDefault();
    const stringToSend = this.value.trim();
    if (stringToSend !== '') {
      sendTX(stringToSend);
      this.value = '';
      logData("\nTX: " + stringToSend);
    }
  }
});

document.getElementById('connectionTypeSelect').addEventListener('change', function() {
  const connectionType = this.value;
  const baudRateSelect = document.getElementById('baudRateSelect');
  if (connectionType === 'serial') {
    baudRateSelect.style.display = 'block';
  } else {
    baudRateSelect.style.display = 'none';
  }
});

function getDeviceInfo() {
  const userAgent = navigator.userAgent;
  let os = 'Unknown OS';
  if (userAgent.indexOf('Win') != -1) os = 'Windows';
  if (userAgent.indexOf('Mac') != -1) os = 'MacOS';
  if (userAgent.indexOf('X11') != -1) os = 'UNIX';
  if (userAgent.indexOf('Linux') != -1) os = 'Linux';
  const browser = navigator.userAgent;
  const deviceInfo = `OS: ${os}, Browser: ${browser}`;
  document.getElementById('deviceInfo').value = deviceInfo;
}

document.addEventListener('DOMContentLoaded', function() {
  getDeviceInfo();
  const userAgent = navigator.userAgent;
  if (!navigator.serial && userAgent.indexOf('Win') == -1 && userAgent.indexOf('Mac') == -1 && userAgent.indexOf('X11') == -1 && userAgent.indexOf('Linux') == -1) {
    // Serial API not supported and OS not detected, default to Bluetooth
    document.getElementById('connectionTypeSelect').value = 'bluetooth';
  } else {
    // Serial API supported or OS detected, user can choose
    document.getElementById('connectionTypeSelect').disabled = false;
  }
});
  </script>
</body>
</html>
