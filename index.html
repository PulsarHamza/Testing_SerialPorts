<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Fetch, Edit, Cache, and Download XML Example</title>
  <style>
    .button {
      display: inline-block;
      padding: 10px 20px;
      background-color: #007bff;
      color: #fff;
      border: none;
      cursor: pointer;
      border-radius: 4px;
      text-decoration: none;
      text-align: center;
      font-size: 16px;
      margin-top: 20px;
    }
  </style>
</head>

<body>
  <h2>Fetch, Edit, Cache, and Download XML Example</h2>

  <button type="button" class="button" onclick="fetchAndCacheXML();">Fetch and Cache XML</button>
  <button type="button" class="button" onclick="downloadXML();">Download Edited XML</button>

  <script>
    let cachedXMLBlobUrl = null;

    // Function to fetch XML, edit it, and cache in local storage
    function fetchAndCacheXML() {
      const xmlUrl = './sample.xml'; // Ensure this file is in the same directory

      fetch(xmlUrl)
        .then(response => {
          if (!response.ok) {
            alert("Error: Network response was not ok");
            throw new Error('Network response was not ok');
          }
          return response.text();
        })
        .then(xmlText => {
          alert("Fetched XML: " + xmlText);
          // Edit the XML (add something random, for example)
          const editedXML = addRandomContent(xmlText);

          // Cache the edited XML in a Blob URL
          if (cachedXMLBlobUrl) {
            URL.revokeObjectURL(cachedXMLBlobUrl);
          }
          const blob = new Blob([editedXML], { type: 'application/xml' });
          cachedXMLBlobUrl = URL.createObjectURL(blob);

          // Optionally display or use the edited XML
          console.log('Edited XML:', editedXML);
          alert("Edited XML: " + editedXML);
        })
        .catch(error => {
          alert('Error fetching XML: ' + error.message);
          console.error('Error fetching XML:', error);
        });
    }

    // Function to simulate editing the XML (add something random)
    function addRandomContent(xmlText) {
      try {
        // Example: Add a random attribute to the root element
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(xmlText, 'application/xml');

        // Check for parsing errors
        if (xmlDoc.getElementsByTagName('parsererror').length > 0) {
          alert("Error parsing XML: " + xmlDoc.getElementsByTagName('parsererror')[0].textContent);
          throw new Error('Error parsing XML');
        }

        const rootElement = xmlDoc.documentElement;

        // Example: Add a random attribute 'randomAttr'
        const randomValue = Math.random().toString(36).substring(7);
        rootElement.setAttribute('randomAttr', randomValue);

        // Serialize XML back to string
        const serializer = new XMLSerializer();
        const editedXML = serializer.serializeToString(xmlDoc);

        return editedXML;
      } catch (error) {
        alert('Error editing XML: ' + error.message);
        console.error('Error editing XML:', error);
      }
    }

    // Function to download XML using form submission
    function downloadXML() {
      if (cachedXMLBlobUrl) {
        const a = document.createElement('a');
        a.href = cachedXMLBlobUrl;
        a.download = 'edited_sample.xml';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
      } else {
        alert('No cached XML to download. Please fetch and edit the XML first.');
        console.error('No cached XML to download. Please fetch and edit the XML first.');
      }
    }
  </script>
</body>

</html>